# Fastlane configuration for {{PROJECT_NAME}} iOS
# Bundle ID: {{BUNDLE_ID}}
# Generated on: $(date)
#
# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

fastlane_version "2.228.0"
default_platform(:ios)

# Disable update checker to prevent initialization issues
ENV["FASTLANE_SKIP_UPDATE_CHECK"] = "1"

# Error handling for FastlaneCore issues
begin
  require 'fastlane'
rescue LoadError => e
  UI.error("Failed to load Fastlane: #{e.message}")
  exit(1)
end

# Project Configuration
PROJECT_NAME = "{{PROJECT_NAME}}"
BUNDLE_ID = "{{BUNDLE_ID}}"
TEAM_ID = "YOUR_TEAM_ID"
KEY_ID = "YOUR_KEY_ID"
ISSUER_ID = "YOUR_ISSUER_ID"
TESTER_GROUPS = ["#{PROJECT_NAME} Internal Testers", "#{PROJECT_NAME} Beta Testers"]

# File paths (relative to fastlane directory)
# Use File.expand_path to ensure absolute path resolution for AuthKey file
KEY_PATH = File.expand_path("./AuthKey_#{KEY_ID}.p8", __dir__)
CHANGELOG_PATH = "../../CHANGELOG.md"
IPA_OUTPUT_DIR = "../../build/ios/ipa"
PUBSPEC_PATH = "../../pubspec.yaml"
# Project-specific paths
PROJECT_KEYSTORE_PATH = "../../app/#{PROJECT_NAME.downcase.gsub(/[^a-z0-9]/, '_')}-release.keystore"

# Function to read version from pubspec.yaml
def read_pubspec_version
  begin
    pubspec_content = File.read(PUBSPEC_PATH)
    version_line = pubspec_content.match(/^version:\s*(.+)$/)
    
    if version_line
      version_string = version_line[1].strip
      # Parse version string like "1.0.0+1"
      if version_string.include?('+')
        version_parts = version_string.split('+')
        version_name = version_parts[0]
        version_code = version_parts[1]
      else
        version_name = version_string
        version_code = "1"
      end
      
      UI.message("üì± Parsed version from pubspec.yaml: #{version_name} (#{version_code})")
      return { version_name: version_name, version_code: version_code }
    else
      UI.error("‚ùå Could not find version in pubspec.yaml")
      return { version_name: "1.0.0", version_code: "1" }
    end
  rescue => e
    UI.error("‚ùå Error reading pubspec.yaml: #{e.message}")
    return { version_name: "1.0.0", version_code: "1" }
  end
end

platform :ios do
  desc "Setup iOS environment"
  lane :setup do
    # Setup tasks would go here
    UI.message("Setting up iOS environment for #{PROJECT_NAME}")
  end

  desc "Build iOS archive for TestFlight"
  lane :build_archive do
    build_archive_beta
  end
  
  desc "Build iOS archive for TestFlight (Beta)"
  lane :build_archive_beta do
    # Read version from pubspec.yaml
    version_info = read_pubspec_version
    UI.message("üîÑ Using version: #{version_info[:version_name]} (#{version_info[:version_code]})")
    
    # Update version number and build number
    increment_version_number(
      version_number: version_info[:version_name]
    )
    increment_build_number(
      build_number: version_info[:version_code]
    )
    
    setup_signing
    
    build_app(
      scheme: "Runner",
      export_method: "app-store",
      output_directory: IPA_OUTPUT_DIR,
      xcargs: "-allowProvisioningUpdates"
    )
  end
  
  desc "Build iOS archive for App Store (Production)"
  lane :build_archive_production do
    # Read version from pubspec.yaml
    version_info = read_pubspec_version
    UI.message("üîÑ Using version: #{version_info[:version_name]} (#{version_info[:version_code]})")
    
    # Update version number and build number
    increment_version_number(
      version_number: version_info[:version_name]
    )
    increment_build_number(
      build_number: version_info[:version_code]
    )
    
    setup_signing
    
    build_app(
      scheme: "Runner",
      export_method: "app-store",
      output_directory: IPA_OUTPUT_DIR,
      xcargs: "-allowProvisioningUpdates",
      export_options: "fastlane/ExportOptions.plist"

    )
  end
  
  desc "Submit a new Beta Build to TestFlight"
  lane :beta do
    if File.exist?("#{IPA_OUTPUT_DIR}/Runner.ipa")
      UI.message("Using existing archive at #{IPA_OUTPUT_DIR}/Runner.ipa")
      upload_to_testflight(
      ipa: "#{IPA_OUTPUT_DIR}/Runner.ipa",
      changelog: read_changelog,
      skip_waiting_for_build_processing: false,
      distribute_external: true,
      groups: TESTER_GROUPS,
      notify_external_testers: true
    )
    else
      UI.message("No existing archive found, building new one...")
      build_archive_beta
      upload_to_testflight(
        changelog: read_changelog,
        skip_waiting_for_build_processing: false,
        distribute_external: true,
        groups: TESTER_GROUPS,
        notify_external_testers: true
      )
    end
  end

  desc "Submit a new Production Build to App Store"
  lane :release do
    if File.exist?("#{IPA_OUTPUT_DIR}/Runner.ipa")
      UI.message("Using existing archive at #{IPA_OUTPUT_DIR}/Runner.ipa")
      upload_to_app_store(
        ipa: "#{IPA_OUTPUT_DIR}/Runner.ipa",
        force: true,
        reject_if_possible: true,
        skip_metadata: false,
        skip_screenshots: false,
        submit_for_review: true,
        automatic_release: true
      )
    else
      UI.message("No existing archive found, building new one...")
      build_archive_production
      upload_to_app_store(
        force: true,
        reject_if_possible: true,
        skip_metadata: false,
        skip_screenshots: false,
        submit_for_review: true,
        automatic_release: true
      )
    end
  end

  desc "Upload existing IPA to TestFlight"
  lane :upload_testflight do
    setup_signing
    
    upload_to_testflight(
        ipa: "#{IPA_OUTPUT_DIR}/Runner.ipa",
        changelog: read_changelog,
        skip_waiting_for_build_processing: false,
        distribute_external: true,
        groups: TESTER_GROUPS,
        notify_external_testers: true
      )
  end

  desc "Upload existing IPA to App Store"
  lane :upload_appstore do
    setup_signing
    
    upload_to_app_store(
      ipa: "#{IPA_OUTPUT_DIR}/Runner.ipa",
      force: true,
      reject_if_possible: true,
      skip_metadata: false,
      skip_screenshots: false,
      submit_for_review: true,
      automatic_release: false
    )
  end

  desc "Clean iOS build artifacts"
  lane :clean do
    # Clean build artifacts
    clear_derived_data
  end
  
  private_lane :setup_signing do
    app_store_connect_api_key(
      key_id: KEY_ID,
      issuer_id: ISSUER_ID,
      key_filepath: KEY_PATH,
      duration: 1200,
      in_house: false
    )
  end
  
  private_lane :read_changelog do |mode = "testing"|
    changelog_content = ""
    
    if File.exist?(CHANGELOG_PATH)
      changelog_content = File.read(CHANGELOG_PATH)
    else
      if mode == "production"
        changelog_content = "üöÄ {{PROJECT_NAME}} Production Release\n\n‚Ä¢ New features and improvements\n‚Ä¢ Performance optimizations\n‚Ä¢ Bug fixes and stability enhancements"
      else
        changelog_content = "üöÄ {{PROJECT_NAME}} Update\n\n‚Ä¢ Performance improvements\n‚Ä¢ Bug fixes and stability enhancements\n‚Ä¢ Updated dependencies"
      end
    end
    
    changelog_content
  end
end