# {{PROJECT_NAME}} - Automated Build & Deployment Makefile
# Generated by AppAutoDeploy - Flutter CI/CD Automation Tool
# Version: 2.0.0 | Enhanced with comprehensive build pipelines

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üìã PROJECT CONFIGURATION
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# Project Information
PROJECT_NAME := {{PROJECT_NAME}}
APP_NAME := {{PROJECT_NAME}}
FLUTTER_VERSION := {{FLUTTER_VERSION}}
PACKAGE_NAME := {{PACKAGE_NAME}}

# Version Configuration - Dynamic (will be updated during build)
# Note: These are fallback values, actual versions will be determined during build
VERSION_FULL_FALLBACK := {{VERSION_FULL}}
VERSION_NAME_FALLBACK := {{VERSION_NAME}}
VERSION_CODE_FALLBACK := {{VERSION_CODE}}

# Output Configuration
OUTPUT_DIR := builder

# Initial filename definitions (will be updated during build)
APK_NAME := {{PROJECT_NAME}}-{{VERSION_NAME}}-{{VERSION_CODE}}.apk
AAB_NAME := {{PROJECT_NAME}}-{{VERSION_NAME}}-{{VERSION_CODE}}.aab
IPA_NAME := {{PROJECT_NAME}}-{{VERSION_NAME}}-{{VERSION_CODE}}.ipa
IPA_PROD_NAME := {{PROJECT_NAME}}-{{VERSION_NAME}}-{{VERSION_CODE}}.ipa
ARCHIVE_NAME := {{PROJECT_NAME}}-{{VERSION_NAME}}-{{VERSION_CODE}}.xcarchive
ARCHIVE_PROD_NAME := {{PROJECT_NAME}}-{{VERSION_NAME}}-{{VERSION_CODE}}.xcarchive

# Function to get current version (will be called during build)
define get_current_version
$(shell dart scripts/dynamic_version_manager.dart get-version 2>/dev/null || echo "$(VERSION_FULL_FALLBACK)")
endef

define get_current_version_name
$(shell dart scripts/dynamic_version_manager.dart get-version-name 2>/dev/null || echo "$(VERSION_NAME_FALLBACK)")
endef

define get_current_version_code
$(shell dart scripts/dynamic_version_manager.dart get-version-code 2>/dev/null || echo "$(VERSION_CODE_FALLBACK)")
endef

# Functions to get platform-specific versions
define get_android_version
$(shell dart scripts/dynamic_version_manager.dart get-android-version 2>/dev/null || echo "$(VERSION_FULL_FALLBACK)")
endef

define get_android_version_name
$(shell dart scripts/dynamic_version_manager.dart get-android-version-name 2>/dev/null || echo "$(VERSION_NAME_FALLBACK)")
endef

define get_android_version_code
$(shell dart scripts/dynamic_version_manager.dart get-android-version-code 2>/dev/null || echo "$(VERSION_CODE_FALLBACK)")
endef

define get_ios_version
$(shell dart scripts/dynamic_version_manager.dart get-ios-version 2>/dev/null || echo "$(VERSION_FULL_FALLBACK)")
endef

define get_ios_version_name
$(shell dart scripts/dynamic_version_manager.dart get-ios-version-name 2>/dev/null || echo "$(VERSION_NAME_FALLBACK)")
endef

define get_ios_version_code
$(shell dart scripts/dynamic_version_manager.dart get-ios-version-code 2>/dev/null || echo "$(VERSION_CODE_FALLBACK)")
endef

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üé® ENHANCED COLORS & STYLES
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# Colors
RED := \033[0;31m
GREEN := \033[0;32m
YELLOW := \033[0;33m
BLUE := \033[0;34m
PURPLE := \033[0;35m
CYAN := \033[0;36m
WHITE := \033[0;37m
GRAY := \033[0;90m
NC := \033[0m

# Styles
BOLD := \033[1m
DIM := \033[2m
UNDERLINE := \033[4m

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üéØ EMOJI & ICONS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# Status Icons
CHECK := ‚úÖ
CROSS := ‚ùå
WARNING := ‚ö†Ô∏è
INFO := ‚ÑπÔ∏è
GEAR := ‚öôÔ∏è
ROCKET := üöÄ
PACKAGE := üì¶
PHONE := üì±
COMPUTER := üíª
SPARKLES := ‚ú®
MAGNIFY := üîç
CLEAN := üßπ
STAR := ‚≠ê
SHIELD := üõ°Ô∏è
WRENCH := üîß

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üñ®Ô∏è PRINT FUNCTIONS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

define print_header
	@printf "\n"
	@printf "$(BLUE)‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó$(NC)\n"
	@printf "$(BLUE)‚ïë$(NC) $(1) $(WHITE)$(2)$(NC) $(BLUE)‚ïë$(NC)\n"
	@printf "$(BLUE)‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù$(NC)\n"
	@printf "\n"
endef

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üéØ DEFAULT TARGET & MENU
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

.DEFAULT_GOAL := menu

menu: ## üéØ Interactive Menu - Choose Your Build Pipeline
	@printf "\n"
	@printf "$(BLUE)‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó$(NC)\n"
	@printf "$(BLUE)‚ïë$(NC) $(PHONE) $(WHITE)$(PROJECT_NAME) - Automated Build Pipelines$(NC) $(BLUE)‚ïë$(NC)\n"
	@printf "$(BLUE)‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù$(NC)\n"
	@printf "\n"
	@printf "$(PURPLE)$(BOLD)üöÄ Automated Build Pipelines:$(NC)\n"
	@printf "\n"
	@printf "$(CYAN)  1)$(NC) $(WHITE)üß™ Tester Pipeline$(NC)         $(GRAY)# APK + TestFlight for testing$(NC)\n"
	@printf "$(CYAN)  2)$(NC) $(WHITE)üöÄ Live Local Pipeline$(NC)     $(GRAY)# AAB + App Store (Local upload)$(NC)\n"
	@printf "$(CYAN)  3)$(NC) $(WHITE)‚òÅÔ∏è  Live GitHub Pipeline$(NC)    $(GRAY)# GitHub Actions deployment$(NC)\n"
	@printf "$(CYAN)  4)$(NC) $(WHITE)üîÑ Live Hybrid Pipeline$(NC)    $(GRAY)# Local build + GitHub upload$(NC)\n"
	@printf "\n"
	@printf "$(PURPLE)$(BOLD)‚öôÔ∏è Advanced Options:$(NC)\n"
	@printf "\n"
	@printf "$(CYAN)  5)$(NC) $(WHITE)‚öôÔ∏è  Manual Operations$(NC)       $(GRAY)# Advanced tools & configurations$(NC)\n"
	@printf "$(CYAN)  6)$(NC) $(WHITE)üîç System Check$(NC)            $(GRAY)# Verify environment setup$(NC)\n"
	@printf "$(CYAN)  7)$(NC) $(WHITE)üìã Help & Commands$(NC)         $(GRAY)# Show all available commands$(NC)\n"
	@printf "$(CYAN)  8)$(NC) $(WHITE)üö™ Exit$(NC)                   $(GRAY)# Close this menu$(NC)\n"
	@printf "\n"
	@printf "$(GRAY)‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ$(NC)\n"
	@printf "$(WHITE)Enter your choice [1-8]:$(NC) "
	@read -p "" CHOICE; \
	case $$CHOICE in \
		1) $(MAKE) auto-build-tester ;; \
		2) $(MAKE) live-local ;; \
		3) $(MAKE) live-github ;; \
		4) $(MAKE) live ;; \
		5) $(MAKE) manual-operations ;; \
		6) $(MAKE) system-check ;; \
		7) $(MAKE) help ;; \
		8) printf "$(GREEN)$(CHECK) %s$(NC)\n" "Goodbye! üëã" ;; \
		*) printf "$(RED)Invalid choice. Please select 1-8.$(NC)\n" && $(MAKE) menu ;; \
	esac

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üß™ TESTER PIPELINE - APK + TESTFLIGHT
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

tester: auto-build-tester ## üß™ Alias for auto-build-tester

auto-build-tester: ## üß™ Automated Tester Pipeline (APK + TestFlight)
	@printf "\n"
	@printf "$(CYAN)üß™ Building for Testing$(NC)\n"
	@printf "\n"
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Checking dependencies..."
	@if command -v ruby >/dev/null 2>&1 && command -v gem >/dev/null 2>&1; then \
		if ! command -v bundle >/dev/null 2>&1; then \
			printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Bundler not found. Installing..."; \
			if gem install bundler 2>/dev/null; then \
				printf "$(GREEN)$(CHECK) %s$(NC)\n" "Bundler installed successfully"; \
			else \
				printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Bundler install failed - continuing without gems"; \
				printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual fix: gem install bundler"; \
			fi; \
		fi; \
		if [ -f "Gemfile" ] && command -v bundle >/dev/null 2>&1; then \
			printf "$(CYAN)$(GEAR) %s$(NC)\n" "Installing Ruby gems..."; \
			if bundle install 2>/dev/null; then \
				printf "$(GREEN)$(CHECK) %s$(NC)\n" "Ruby gems installed"; \
			else \
				printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Bundle install failed - continuing without gems"; \
				printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual fix: bundle install"; \
			fi; \
		fi; \
	else \
		printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Ruby/Gems not found - skipping gem dependencies"; \
		printf "$(CYAN)$(INFO) %s$(NC)\n" "Install Ruby if you need Fastlane functionality"; \
	fi
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Starting system configuration check..."
	@printf "$(CYAN)üîç System Configuration Check$(NC)\n"
	@printf "\n"
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Checking Flutter installation..."
	@if command -v flutter >/dev/null 2>&1; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "Flutter installed"; else printf "$(RED)$(CROSS) %s$(NC)\n" "Flutter not installed"; fi
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Checking project structure..."
	@if [ -f "pubspec.yaml" ]; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "pubspec.yaml found"; else printf "$(RED)$(CROSS) %s$(NC)\n" "pubspec.yaml missing"; fi
	@if [ -d "android" ]; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "Android directory found"; else printf "$(RED)$(CROSS) %s$(NC)\n" "Android directory missing"; fi
	@if [ -d "ios" ]; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS directory found"; else printf "$(RED)$(CROSS) %s$(NC)\n" "iOS directory missing"; fi
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Interactive version selection..."
	@if command -v dart >/dev/null 2>&1; then \
		printf "$(CYAN)$(GEAR) %s$(NC)\n" "Preparing version selection context..."; \
		if [ -n "$(ANDROID_VERSION_NAME)" ] && [ -n "$(ANDROID_VERSION_CODE)" ] && [ -n "$(IOS_VERSION_NAME)" ] && [ -n "$(IOS_VERSION_CODE)" ]; then \
			printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual versions detected: ANDROID=$(ANDROID_VERSION_NAME)+$(ANDROID_VERSION_CODE), iOS=$(IOS_VERSION_NAME)+$(IOS_VERSION_CODE)"; \
			VERSION_MODE=manual ANDROID_VERSION_NAME="$(ANDROID_VERSION_NAME)" ANDROID_VERSION_CODE="$(ANDROID_VERSION_CODE)" IOS_VERSION_NAME="$(IOS_VERSION_NAME)" IOS_VERSION_CODE="$(IOS_VERSION_CODE)" dart scripts/dynamic_version_manager.dart interactive 2>/dev/null; \
		else \
			dart scripts/dynamic_version_manager.dart interactive 2>/dev/null; \
		fi; \
		if [ $$? -eq 0 ]; then \
			printf "$(GREEN)$(CHECK) %s$(NC)\n" "Version applied successfully"; \
		else \
			printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Interactive version failed - using fallback"; \
			if dart scripts/dynamic_version_manager.dart set-strategy fallback_only && dart scripts/dynamic_version_manager.dart apply; then \
				printf "$(GREEN)$(CHECK) %s$(NC)\n" "Fallback version applied"; \
			else \
				printf "$(RED)$(CROSS) %s$(NC)\n" "Version management failed"; \
			fi; \
		fi; \
	else \
		printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Dart not found - skipping dynamic version management"; \
	fi
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Refreshing version information after interactive selection..."
	$(eval VERSION_FULL := $(call get_current_version))
	$(eval VERSION_NAME := $(call get_current_version_name))
	$(eval VERSION_CODE := $(call get_current_version_code))
	$(eval ANDROID_VERSION_NAME := $(call get_android_version_name))
	$(eval ANDROID_VERSION_CODE := $(call get_android_version_code))
	$(eval IOS_VERSION_NAME := $(call get_ios_version_name))
	$(eval IOS_VERSION_CODE := $(call get_ios_version_code))
	$(eval APK_NAME := $(PROJECT_NAME)-$(ANDROID_VERSION_NAME)-$(ANDROID_VERSION_CODE).apk)
	$(eval AAB_NAME := $(PROJECT_NAME)-$(ANDROID_VERSION_NAME)-$(ANDROID_VERSION_CODE).aab)
	$(eval IPA_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).ipa)
	$(eval IPA_PROD_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).ipa)
	$(eval ARCHIVE_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).xcarchive)
	$(eval ARCHIVE_PROD_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).xcarchive)
	@printf "$(GREEN)$(CHECK) %s$(NC)\n" "Version refreshed:"
	@printf "$(CYAN)   üì± Android: $(ANDROID_VERSION_NAME)+$(ANDROID_VERSION_CODE)$(NC)\n"
	@printf "$(CYAN)   üçé iOS: $(IOS_VERSION_NAME)+$(IOS_VERSION_CODE)$(NC)\n"
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Creating Builder Directory"
	@mkdir -p $(OUTPUT_DIR)
	@printf "$(GREEN)$(CHECK) %s$(NC)\n" "Builder directory ready"
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Refreshing version information after interactive selection..."
	$(eval VERSION_FULL := $(call get_current_version))
	$(eval VERSION_NAME := $(call get_current_version_name))
	$(eval VERSION_CODE := $(call get_current_version_code))
	$(eval ANDROID_VERSION_NAME := $(call get_android_version_name))
	$(eval ANDROID_VERSION_CODE := $(call get_android_version_code))
	$(eval IOS_VERSION_NAME := $(call get_ios_version_name))
	$(eval IOS_VERSION_CODE := $(call get_ios_version_code))
	$(eval APK_NAME := $(PROJECT_NAME)-$(ANDROID_VERSION_NAME)-$(ANDROID_VERSION_CODE).apk)
	$(eval AAB_NAME := $(PROJECT_NAME)-$(ANDROID_VERSION_NAME)-$(ANDROID_VERSION_CODE).aab)
	$(eval IPA_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).ipa)
	$(eval IPA_PROD_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).ipa)
	$(eval ARCHIVE_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).xcarchive)
	$(eval ARCHIVE_PROD_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).xcarchive)
	@printf "$(GREEN)$(CHECK) %s$(NC)\n" "Version refreshed:"
	@printf "$(CYAN)   üì± Android: $(ANDROID_VERSION_NAME)+$(ANDROID_VERSION_CODE)$(NC)\n"
	@printf "$(CYAN)   üçé iOS: $(IOS_VERSION_NAME)+$(IOS_VERSION_CODE)$(NC)\n"
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Refreshing version information after interactive selection..."
	$(eval VERSION_FULL := $(call get_current_version))
	$(eval VERSION_NAME := $(call get_current_version_name))
	$(eval VERSION_CODE := $(call get_current_version_code))
	$(eval ANDROID_VERSION_NAME := $(call get_android_version_name))
	$(eval ANDROID_VERSION_CODE := $(call get_android_version_code))
	$(eval IOS_VERSION_NAME := $(call get_ios_version_name))
	$(eval IOS_VERSION_CODE := $(call get_ios_version_code))
	$(eval APK_NAME := $(PROJECT_NAME)-$(ANDROID_VERSION_NAME)-$(ANDROID_VERSION_CODE).apk)
	$(eval AAB_NAME := $(PROJECT_NAME)-$(ANDROID_VERSION_NAME)-$(ANDROID_VERSION_CODE).aab)
	$(eval IPA_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).ipa)
	$(eval IPA_PROD_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).ipa)
	$(eval ARCHIVE_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).xcarchive)
	$(eval ARCHIVE_PROD_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).xcarchive)
	@printf "$(GREEN)$(CHECK) %s$(NC)\n" "Version refreshed:"
	@printf "$(CYAN)   üì± Android: $(ANDROID_VERSION_NAME)+$(ANDROID_VERSION_CODE)$(NC)\n"
	@printf "$(CYAN)   üçé iOS: $(IOS_VERSION_NAME)+$(IOS_VERSION_CODE)$(NC)\n"
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Refreshing version information after interactive selection..."
	$(eval VERSION_FULL := $(call get_current_version))
	$(eval VERSION_NAME := $(call get_current_version_name))
	$(eval VERSION_CODE := $(call get_current_version_code))
	$(eval ANDROID_VERSION_NAME := $(call get_android_version_name))
	$(eval ANDROID_VERSION_CODE := $(call get_android_version_code))
	$(eval IOS_VERSION_NAME := $(call get_ios_version_name))
	$(eval IOS_VERSION_CODE := $(call get_ios_version_code))
	$(eval APK_NAME := $(PROJECT_NAME)-$(ANDROID_VERSION_NAME)-$(ANDROID_VERSION_CODE).apk)
	$(eval AAB_NAME := $(PROJECT_NAME)-$(ANDROID_VERSION_NAME)-$(ANDROID_VERSION_CODE).aab)
	$(eval IPA_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).ipa)
	$(eval IPA_PROD_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).ipa)
	$(eval ARCHIVE_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).xcarchive)
	$(eval ARCHIVE_PROD_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).xcarchive)
	@printf "$(GREEN)$(CHECK) %s$(NC)\n" "Version refreshed:"
	@printf "$(CYAN)   üì± Android: $(ANDROID_VERSION_NAME)+$(ANDROID_VERSION_CODE)$(NC)\n"
	@printf "$(CYAN)   üçé iOS: $(IOS_VERSION_NAME)+$(IOS_VERSION_CODE)$(NC)\n"
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Generating build information..."
	@if command -v dart >/dev/null 2>&1; then \
		if dart scripts/build_info_generator.dart 2>/dev/null; then \
			printf "$(GREEN)$(CHECK) %s$(NC)\n" "Build information generated"; \
		else \
			printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Build info generation failed - continuing"; \
		fi; \
	else \
		printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Dart not found - skipping build info generation"; \
	fi
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Building Android APK for Testing"
	@flutter clean && flutter pub get
	@flutter build apk --release
	@if [ -f "build/app/outputs/flutter-apk/app-release.apk" ]; then \
		APK_SIZE=$$(du -h "build/app/outputs/flutter-apk/app-release.apk" | awk '{print $$1}'); \
		printf "$(GREEN)$(CHECK) %s ($$APK_SIZE)$(NC)\n" "Android APK built successfully"; \
		cp "build/app/outputs/flutter-apk/app-release.apk" "$(OUTPUT_DIR)/$(APK_NAME)"; \
		printf "$(GREEN)$(CHECK) %s$(NC)\n" "APK copied to $(OUTPUT_DIR)/$(APK_NAME)"; \
	else \
		printf "$(RED)$(CROSS) %s$(NC)\n" "Android APK build failed"; \
		exit 1; \
	fi
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Building iOS for TestFlight"
	@if [ "$$(uname)" = "Darwin" ]; then \
		printf "$(CYAN)$(GEAR) %s$(NC)\n" "Cleaning iOS dependencies..."; \
		cd ios && rm -rf Pods Podfile.lock Pods/Manifest.lock && pod install && cd ..; \
		printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS dependencies cleaned and reinstalled"; \
		flutter build ios --release; \
		if [ $$? -eq 0 ]; then \
			printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS build completed"; \
			mkdir -p build/ios/archive build/ios/ipa; \
			printf "$(CYAN)$(GEAR) %s$(NC)\n" "Building and exporting IPA using Fastlane..."; \
			if command -v fastlane >/dev/null 2>&1 && [ -f "ios/fastlane/Fastfile" ]; then \
				cd ios; \
				if fastlane build_archive_beta 2>/dev/null; then \
					printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS Archive and IPA created successfully"; \
					cd ..; \
					IPA_FILE=$$(find build/ios/ipa -name "*.ipa" | head -1); \
					if [ -n "$$IPA_FILE" ] && [ -f "$$IPA_FILE" ]; then \
						printf "$(GREEN)$(CHECK) %s$(NC)\n" "TestFlight IPA exported successfully"; \
						cp "$$IPA_FILE" "$(OUTPUT_DIR)/$(IPA_NAME)"; \
						printf "$(GREEN)$(CHECK) %s$(NC)\n" "TestFlight IPA copied to $(OUTPUT_DIR)/$(IPA_NAME)"; \
						printf "$(CYAN)$(GEAR) %s$(NC)\n" "Uploading to TestFlight..."; \
						cd ios; \
						if fastlane ios beta 2>/dev/null; then \
							printf "$(GREEN)$(CHECK) %s$(NC)\n" "Successfully uploaded to TestFlight"; \
						else \
							printf "$(YELLOW)$(WARNING) %s$(NC)\n" "TestFlight upload failed - check fastlane configuration"; \
							printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual upload: Use Xcode or: cd ios && fastlane ios beta"; \
						fi; \
						cd ..; \
					else \
						printf "$(RED)$(CROSS) %s$(NC)\n" "IPA export failed"; \
					fi; \
				else \
					printf "$(RED)$(CROSS) %s$(NC)\n" "Fastlane build failed"; \
					exit 1; \
				fi; \
			else \
				printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Fastlane not available"; \
			fi; \
		else \
			printf "$(RED)$(CROSS) %s$(NC)\n" "iOS build failed"; \
			exit 1; \
		fi; \
	else \
		printf "$(YELLOW)$(WARNING) %s$(NC)\n" "iOS build skipped (requires macOS)"; \
	fi
	
	@printf "$(GREEN)$(CHECK) %s$(NC)\n" "Tester build completed"
	@printf "$(GREEN)üéâ Tester Build Pipeline Completed!$(NC)\n"
	@printf "$(WHITE)üìÅ Builder Directory:$(NC) $(OUTPUT_DIR)/\n"
	@printf "$(WHITE)üì± Android APK:$(NC) $(OUTPUT_DIR)/$(APK_NAME)\n"
	@if [ "$$(uname)" = "Darwin" ] && [ -f "$(OUTPUT_DIR)/$(IPA_NAME)" ]; then \
		printf "$(WHITE)üçé iOS IPA:$(NC) $(OUTPUT_DIR)/$(IPA_NAME)\n"; \
	fi

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üåü LIVE PRODUCTION PIPELINE - AAB + APP STORE
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

live: ## üîÑ Automated Live Production Pipeline (Hybrid)
	@printf "\n"
	@printf "$(CYAN)üåü Building for Production$(NC)\n"
	@printf "\n"
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Checking dependencies..."
	@if command -v ruby >/dev/null 2>&1 && command -v gem >/dev/null 2>&1; then \
		if ! command -v bundle >/dev/null 2>&1; then \
			printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Bundler not found. Installing..."; \
			if gem install bundler 2>/dev/null; then \
				printf "$(GREEN)$(CHECK) %s$(NC)\n" "Bundler installed successfully"; \
			else \
				printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Bundler install failed - continuing without gems"; \
				printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual fix: gem install bundler"; \
			fi; \
		fi; \
		if [ -f "Gemfile" ] && command -v bundle >/dev/null 2>&1; then \
			printf "$(CYAN)$(GEAR) %s$(NC)\n" "Installing Ruby gems..."; \
			if bundle install 2>/dev/null; then \
				printf "$(GREEN)$(CHECK) %s$(NC)\n" "Ruby gems installed"; \
			else \
				printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Bundle install failed - continuing without gems"; \
				printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual fix: bundle install"; \
			fi; \
		fi; \
	else \
		printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Ruby/Gems not found - skipping gem dependencies"; \
		printf "$(CYAN)$(INFO) %s$(NC)\n" "Install Ruby if you need Fastlane functionality"; \
	fi
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Starting system configuration check..."
	@printf "$(CYAN)üîç System Configuration Check$(NC)\n"
	@printf "\n"
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Checking Flutter installation..."
	@if command -v flutter >/dev/null 2>&1; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "Flutter installed"; else printf "$(RED)$(CROSS) %s$(NC)\n" "Flutter not installed"; fi
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Checking project structure..."
	@if [ -f "pubspec.yaml" ]; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "pubspec.yaml found"; else printf "$(RED)$(CROSS) %s$(NC)\n" "pubspec.yaml missing"; fi
	@if [ -d "android" ]; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "Android directory found"; else printf "$(RED)$(CROSS) %s$(NC)\n" "Android directory missing"; fi
	@if [ -d "ios" ]; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS directory found"; else printf "$(RED)$(CROSS) %s$(NC)\n" "iOS directory missing"; fi
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Interactive version selection..."
	@if command -v dart >/dev/null 2>&1; then \
		if dart scripts/dynamic_version_manager.dart interactive 2>/dev/null; then \
			printf "$(GREEN)$(CHECK) %s$(NC)\n" "Version applied successfully"; \
		else \
			printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Interactive version failed - using fallback"; \
			if dart scripts/dynamic_version_manager.dart set-strategy fallback_only && dart scripts/dynamic_version_manager.dart apply; then \
				printf "$(GREEN)$(CHECK) %s$(NC)\n" "Fallback version applied"; \
			else \
				printf "$(RED)$(CROSS) %s$(NC)\n" "Version management failed"; \
			fi; \
		fi; \
	else \
		printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Dart not found - skipping dynamic version management"; \
	fi
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Refreshing version information after interactive selection..."
	$(eval VERSION_FULL := $(call get_current_version))
	$(eval VERSION_NAME := $(call get_current_version_name))
	$(eval VERSION_CODE := $(call get_current_version_code))
	$(eval ANDROID_VERSION_NAME := $(call get_android_version_name))
	$(eval ANDROID_VERSION_CODE := $(call get_android_version_code))
	$(eval IOS_VERSION_NAME := $(call get_ios_version_name))
	$(eval IOS_VERSION_CODE := $(call get_ios_version_code))
	$(eval APK_NAME := $(PROJECT_NAME)-$(ANDROID_VERSION_NAME)-$(ANDROID_VERSION_CODE).apk)
	$(eval AAB_NAME := $(PROJECT_NAME)-$(ANDROID_VERSION_NAME)-$(ANDROID_VERSION_CODE).aab)
	$(eval IPA_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).ipa)
	$(eval IPA_PROD_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).ipa)
	$(eval ARCHIVE_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).xcarchive)
	$(eval ARCHIVE_PROD_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).xcarchive)
	@printf "$(GREEN)$(CHECK) %s$(NC)\n" "Version refreshed:"
	@printf "$(CYAN)   üì± Android: $(ANDROID_VERSION_NAME)+$(ANDROID_VERSION_CODE)$(NC)\n"
	@printf "$(CYAN)   üçé iOS: $(IOS_VERSION_NAME)+$(IOS_VERSION_CODE)$(NC)\n"
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Creating Builder Directory"
	@mkdir -p $(OUTPUT_DIR)
	@printf "$(GREEN)$(CHECK) %s$(NC)\n" "Builder directory ready"
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Generating build information..."
	@if command -v dart >/dev/null 2>&1; then \
		if dart scripts/build_info_generator.dart 2>/dev/null; then \
			printf "$(GREEN)$(CHECK) %s$(NC)\n" "Build information generated"; \
		else \
			printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Build info generation failed - continuing"; \
		fi; \
	else \
		printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Dart not found - skipping build info generation"; \
	fi
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Building Android AAB for Google Play Production"
	@flutter clean && flutter pub get
	@flutter build appbundle --release
	@if [ -f "build/app/outputs/bundle/release/app-release.aab" ]; then \
		AAB_SIZE=$$(du -h "build/app/outputs/bundle/release/app-release.aab" | awk '{print $$1}'); \
		printf "$(GREEN)$(CHECK) %s ($$AAB_SIZE)$(NC)\n" "Android AAB built successfully"; \
		cp "build/app/outputs/bundle/release/app-release.aab" "$(OUTPUT_DIR)/$(AAB_NAME)"; \
		printf "$(GREEN)$(CHECK) %s$(NC)\n" "AAB copied to $(OUTPUT_DIR)/$(AAB_NAME)"; \
	else \
		printf "$(RED)$(CROSS) %s$(NC)\n" "Android AAB build failed"; \
		exit 1; \
	fi
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Building iOS for App Store"
	@if [ "$$(uname)" = "Darwin" ]; then \
		printf "$(CYAN)$(GEAR) %s$(NC)\n" "Cleaning iOS dependencies..."; \
		cd ios && rm -rf Pods Podfile.lock Pods/Manifest.lock && pod install && cd ..; \
		printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS dependencies cleaned and reinstalled"; \
		flutter build ios --release; \
		if [ $$? -eq 0 ]; then \
			printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS build completed"; \
			mkdir -p build/ios/archive build/ios/ipa; \
			printf "$(CYAN)$(GEAR) %s$(NC)\n" "Building and exporting Production IPA using Fastlane..."; \
			if command -v fastlane >/dev/null 2>&1 && [ -f "ios/fastlane/Fastfile" ]; then \
				cd ios; \
				if command -v bundle >/dev/null 2>&1 && [ -f "../Gemfile" ]; then \
					if bundle exec fastlane build_archive_production 2>/dev/null; then \
						printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS Archive and Production IPA created successfully via bundle"; \
					elif fastlane build_archive_production 2>/dev/null; then \
						printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS Archive and Production IPA created successfully"; \
					else \
						printf "$(RED)$(CROSS) %s$(NC)\n" "Fastlane production build failed"; \
						exit 1; \
					fi; \
				elif fastlane build_archive_production 2>/dev/null; then \
					printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS Archive and Production IPA created successfully"; \
				else \
					printf "$(RED)$(CROSS) %s$(NC)\n" "Fastlane production build failed"; \
					exit 1; \
				fi; \
				cd ..; \
				IPA_FILE=$$(find build/ios/ipa -name "*.ipa" 2>/dev/null | head -1); \
				if [ -z "$$IPA_FILE" ]; then \
					IPA_FILE=$$(find ios/fastlane/builds -name "*.ipa" 2>/dev/null | head -1); \
				fi; \
				if [ -z "$$IPA_FILE" ]; then \
					IPA_FILE=$$(find . -name "*.ipa" -path "*/build/*" -o -path "*/fastlane/*" 2>/dev/null | head -1); \
				fi; \
				if [ -n "$$IPA_FILE" ] && [ -f "$$IPA_FILE" ]; then \
					printf "$(GREEN)$(CHECK) %s$(NC)\n" "Production IPA exported successfully: $$IPA_FILE"; \
					cp "$$IPA_FILE" "$(OUTPUT_DIR)/$(IPA_PROD_NAME)"; \
					printf "$(GREEN)$(CHECK) %s$(NC)\n" "Production IPA copied to $(OUTPUT_DIR)/$(IPA_PROD_NAME)"; \
					printf "$(CYAN)$(GEAR) %s$(NC)\n" "Uploading to App Store..."; \
					cd ios; \
					if command -v bundle >/dev/null 2>&1 && [ -f "../Gemfile" ]; then \
						if bundle exec fastlane ios release 2>/dev/null; then \
							printf "$(GREEN)$(CHECK) %s$(NC)\n" "Successfully uploaded to App Store via bundle"; \
						elif fastlane ios release 2>/dev/null; then \
							printf "$(GREEN)$(CHECK) %s$(NC)\n" "Successfully uploaded to App Store"; \
						else \
							printf "$(YELLOW)$(WARNING) %s$(NC)\n" "App Store upload failed - check fastlane configuration"; \
							printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual upload: Use Xcode or: cd ios && bundle exec fastlane ios release"; \
						fi; \
					elif fastlane ios release 2>/dev/null; then \
						printf "$(GREEN)$(CHECK) %s$(NC)\n" "Successfully uploaded to App Store"; \
					else \
						printf "$(YELLOW)$(WARNING) %s$(NC)\n" "App Store upload failed - check fastlane configuration"; \
						printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual upload: Use Xcode or: cd ios && fastlane ios release"; \
					fi; \
					cd ..; \
				else \
					printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Production IPA not found in expected locations - build may have succeeded but IPA location differs"; \
					printf "$(CYAN)$(INFO) %s$(NC)\n" "Check fastlane logs above for actual build status"; \
				fi; \
			else \
				printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Fastlane not available - falling back to xcodebuild"; \
				cd ios && xcodebuild -workspace Runner.xcworkspace -scheme Runner -configuration Release -destination "generic/platform=iOS" -archivePath ../build/ios/archive/Runner.xcarchive archive; \
				if [ $$? -eq 0 ] && [ -d "../build/ios/archive/Runner.xcarchive" ]; then \
					printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS Archive created successfully"; \
					cp -r "../build/ios/archive/Runner.xcarchive" "../$(OUTPUT_DIR)/$(ARCHIVE_PROD_NAME)"; \
					printf "$(GREEN)$(CHECK) %s$(NC)\n" "Archive copied to $(OUTPUT_DIR)/$(ARCHIVE_PROD_NAME)"; \
					printf "$(CYAN)$(GEAR) %s$(NC)\n" "Exporting Production IPA from Archive..."; \
					if [ -f "fastlane/ExportOptions.plist" ]; then \
						xcodebuild -exportArchive -archivePath ../build/ios/archive/Runner.xcarchive -exportPath ../build/ios/ipa -exportOptionsPlist fastlane/ExportOptions.plist; \
					else \
						TEMP_PLIST=$$(mktemp /tmp/ExportOptions.XXXXXX.plist); \
						printf '<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n<plist version="1.0">\n<dict>\n<key>method</key>\n<string>app-store</string>\n<key>uploadBitcode</key>\n<false/>\n<key>compileBitcode</key>\n<false/>\n<key>uploadSymbols</key>\n<true/>\n<key>signingStyle</key>\n<string>automatic</string>\n</dict>\n</plist>' > "$$TEMP_PLIST"; \
						xcodebuild -exportArchive -archivePath ../build/ios/archive/Runner.xcarchive -exportPath ../build/ios/ipa -exportOptionsPlist "$$TEMP_PLIST"; \
						rm -f "$$TEMP_PLIST"; \
					fi; \
					IPA_FILE=$$(find ../build/ios/ipa -name "*.ipa" | head -1); \
					if [ -n "$$IPA_FILE" ] && [ -f "$$IPA_FILE" ]; then \
						printf "$(GREEN)$(CHECK) %s$(NC)\n" "Production IPA exported successfully"; \
						cp "$$IPA_FILE" "../$(OUTPUT_DIR)/$(IPA_PROD_NAME)"; \
						printf "$(GREEN)$(CHECK) %s$(NC)\n" "Production IPA copied to $(OUTPUT_DIR)/$(IPA_PROD_NAME)"; \
						printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual App Store upload required"; \
						printf "$(CYAN)$(INFO) %s$(NC)\n" "IPA location: $(OUTPUT_DIR)/$(IPA_PROD_NAME)"; \
					else \
						printf "$(RED)$(CROSS) %s$(NC)\n" "Production IPA export failed"; \
					fi; \
				fi; \
				cd ..; \
			fi; \
		fi; \
	else \
		printf "$(YELLOW)$(WARNING) %s$(NC)\n" "iOS build skipped (requires macOS)"; \
	fi
	
	@printf "$(GREEN)$(CHECK) %s$(NC)\n" "Production build completed"
	@printf "$(GREEN)üöÄ Live Production Pipeline Completed!$(NC)\n"
	@printf "$(WHITE)üìÅ Builder Directory:$(NC) $(OUTPUT_DIR)/\n"
	@printf "$(WHITE)üì¶ Android AAB:$(NC) $(OUTPUT_DIR)/$(AAB_NAME)\n"
	@printf "$(WHITE)üì¶ Android AAB (builder/):$(NC) builder/$(AAB_NAME)\n"
	@if [ "$$(uname)" = "Darwin" ] && [ -f "$(OUTPUT_DIR)/$(IPA_PROD_NAME)" ]; then \
		printf "$(WHITE)üçé iOS Production IPA:$(NC) $(OUTPUT_DIR)/$(IPA_PROD_NAME)\n"; \
		printf "$(WHITE)üçé iOS Production IPA (builder/):$(NC) builder/$(IPA_PROD_NAME)\n"; \
	fi
	
	@printf "\n"
	@printf "$(CYAN)üöÄ Triggering GitHub Actions for Store Upload...$(NC)\n"
	@$(MAKE) trigger-github-actions

live-local: ## üöÄ Automated Live Production Pipeline (Local Only)
	@printf "\n"
	@printf "$(CYAN)üåü Building for Production (Local Upload)$(NC)\n"
	@printf "\n"
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Checking dependencies..."
	@if command -v ruby >/dev/null 2>&1 && command -v gem >/dev/null 2>&1; then \
		if ! command -v bundle >/dev/null 2>&1; then \
			printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Bundler not found. Installing..."; \
			if gem install bundler 2>/dev/null; then \
				printf "$(GREEN)$(CHECK) %s$(NC)\n" "Bundler installed successfully"; \
			else \
				printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Bundler install failed - continuing without gems"; \
				printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual fix: gem install bundler"; \
			fi; \
		fi; \
		if [ -f "Gemfile" ] && command -v bundle >/dev/null 2>&1; then \
			printf "$(CYAN)$(GEAR) %s$(NC)\n" "Installing Ruby gems..."; \
			if bundle install 2>/dev/null; then \
				printf "$(GREEN)$(CHECK) %s$(NC)\n" "Ruby gems installed"; \
			else \
				printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Bundle install failed - continuing without gems"; \
				printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual fix: bundle install"; \
			fi; \
		fi; \
	else \
		printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Ruby/Gems not found - skipping gem dependencies"; \
		printf "$(CYAN)$(INFO) %s$(NC)\n" "Install Ruby if you need Fastlane functionality"; \
	fi
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Starting system configuration check..."
	@printf "$(CYAN)üîç System Configuration Check$(NC)\n"
	@printf "\n"
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Checking Flutter installation..."
	@if command -v flutter >/dev/null 2>&1; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "Flutter installed"; else printf "$(RED)$(CROSS) %s$(NC)\n" "Flutter not installed"; fi
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Checking project structure..."
	@if [ -f "pubspec.yaml" ]; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "pubspec.yaml found"; else printf "$(RED)$(CROSS) %s$(NC)\n" "pubspec.yaml missing"; fi
	@if [ -d "android" ]; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "Android directory found"; else printf "$(RED)$(CROSS) %s$(NC)\n" "Android directory missing"; fi
	@if [ -d "ios" ]; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS directory found"; else printf "$(RED)$(CROSS) %s$(NC)\n" "iOS directory missing"; fi
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Interactive version selection..."
	@if command -v dart >/dev/null 2>&1; then \
		if dart scripts/dynamic_version_manager.dart interactive 2>/dev/null; then \
			printf "$(GREEN)$(CHECK) %s$(NC)\n" "Version applied successfully"; \
		else \
			printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Interactive version failed - using fallback"; \
			if dart scripts/dynamic_version_manager.dart set-strategy fallback_only && dart scripts/dynamic_version_manager.dart apply; then \
				printf "$(GREEN)$(CHECK) %s$(NC)\n" "Fallback version applied"; \
			else \
				printf "$(RED)$(CROSS) %s$(NC)\n" "Version management failed"; \
			fi; \
		fi; \
	else \
		printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Dart not found - skipping dynamic version management"; \
	fi
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Refreshing version information after interactive selection..."
	$(eval VERSION_FULL := $(call get_current_version))
	$(eval VERSION_NAME := $(call get_current_version_name))
	$(eval VERSION_CODE := $(call get_current_version_code))
	$(eval ANDROID_VERSION_NAME := $(call get_android_version_name))
	$(eval ANDROID_VERSION_CODE := $(call get_android_version_code))
	$(eval IOS_VERSION_NAME := $(call get_ios_version_name))
	$(eval IOS_VERSION_CODE := $(call get_ios_version_code))
	$(eval APK_NAME := $(PROJECT_NAME)-$(ANDROID_VERSION_NAME)-$(ANDROID_VERSION_CODE).apk)
	$(eval AAB_NAME := $(PROJECT_NAME)-$(ANDROID_VERSION_NAME)-$(ANDROID_VERSION_CODE).aab)
	$(eval IPA_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).ipa)
	$(eval IPA_PROD_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).ipa)
	$(eval ARCHIVE_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).xcarchive)
	$(eval ARCHIVE_PROD_NAME := $(PROJECT_NAME)-$(IOS_VERSION_NAME)-$(IOS_VERSION_CODE).xcarchive)
	@printf "$(GREEN)$(CHECK) %s$(NC)\n" "Version refreshed:"
	@printf "$(CYAN)   üì± Android: $(ANDROID_VERSION_NAME)+$(ANDROID_VERSION_CODE)$(NC)\n"
	@printf "$(CYAN)   üçé iOS: $(IOS_VERSION_NAME)+$(IOS_VERSION_CODE)$(NC)\n"
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Creating Builder Directory"
	@mkdir -p $(OUTPUT_DIR)
	@printf "$(GREEN)$(CHECK) %s$(NC)\n" "Builder directory ready"
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Generating build information..."
	@if command -v dart >/dev/null 2>&1; then \
		if dart scripts/build_info_generator.dart 2>/dev/null; then \
			printf "$(GREEN)$(CHECK) %s$(NC)\n" "Build information generated"; \
		else \
			printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Build info generation failed - continuing"; \
		fi; \
	else \
		printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Dart not found - skipping build info generation"; \
	fi
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Building Android AAB for Google Play Production"
	@flutter clean && flutter pub get
	@flutter build appbundle --release
	@if [ -f "build/app/outputs/bundle/release/app-release.aab" ]; then \
		AAB_SIZE=$$(du -h "build/app/outputs/bundle/release/app-release.aab" | awk '{print $$1}'); \
		printf "$(GREEN)$(CHECK) %s ($$AAB_SIZE)$(NC)\n" "Android AAB built successfully"; \
		cp "build/app/outputs/bundle/release/app-release.aab" "$(OUTPUT_DIR)/$(AAB_NAME)"; \
		printf "$(GREEN)$(CHECK) %s$(NC)\n" "AAB copied to $(OUTPUT_DIR)/$(AAB_NAME)"; \
		printf "$(CYAN)$(GEAR) %s$(NC)\n" "Uploading Android AAB to Google Play..."; \
		if command -v fastlane >/dev/null 2>&1 && [ -f "android/fastlane/Fastfile" ]; then \
			cd android; \
			if command -v bundle >/dev/null 2>&1 && [ -f "../Gemfile" ]; then \
				export FASTLANE_JSON_KEY_FILE="play_store_service_account.json"; \
				if bundle exec fastlane android release 2>/dev/null; then \
					printf "$(GREEN)$(CHECK) %s$(NC)\n" "Successfully uploaded to Google Play via bundle"; \
				elif fastlane android release 2>/dev/null; then \
					printf "$(GREEN)$(CHECK) %s$(NC)\n" "Successfully uploaded to Google Play"; \
				else \
					printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Google Play upload failed - check fastlane configuration"; \
					printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual upload: cd android && bundle exec fastlane android release"; \
				fi; \
			elif fastlane android release 2>/dev/null; then \
				export FASTLANE_JSON_KEY_FILE="play_store_service_account.json"; \
				printf "$(GREEN)$(CHECK) %s$(NC)\n" "Successfully uploaded to Google Play"; \
			else \
				printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Google Play upload failed - check fastlane configuration"; \
				printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual upload: cd android && fastlane android release"; \
			fi; \
			cd ..; \
		else \
			printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Fastlane not available - manual Google Play upload required"; \
			printf "$(CYAN)$(INFO) %s$(NC)\n" "Upload manually: Use Google Play Console"; \
			printf "$(CYAN)$(INFO) %s$(NC)\n" "AAB location: $(OUTPUT_DIR)/$(AAB_NAME)"; \
		fi; \
	else \
		printf "$(RED)$(CROSS) %s$(NC)\n" "Android AAB build failed"; \
		exit 1; \
	fi
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Building iOS for App Store"
	@if [ "$$(uname)" = "Darwin" ]; then \
		printf "$(CYAN)$(GEAR) %s$(NC)\n" "Cleaning iOS dependencies..."; \
		cd ios && rm -rf Pods Podfile.lock Pods/Manifest.lock && pod install && cd ..; \
		printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS dependencies cleaned and reinstalled"; \
		flutter build ios --release; \
		if [ $$? -eq 0 ]; then \
			printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS build completed"; \
			mkdir -p build/ios/archive build/ios/ipa; \
			printf "$(CYAN)$(GEAR) %s$(NC)\n" "Building and exporting Production IPA using Fastlane..."; \
			if command -v fastlane >/dev/null 2>&1 && [ -f "ios/fastlane/Fastfile" ]; then \
				cd ios; \
				if command -v bundle >/dev/null 2>&1 && [ -f "../Gemfile" ]; then \
					if bundle exec fastlane build_archive_production 2>/dev/null; then \
						printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS Archive and Production IPA created successfully via bundle"; \
					elif fastlane build_archive_production 2>/dev/null; then \
						printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS Archive and Production IPA created successfully"; \
					else \
						printf "$(RED)$(CROSS) %s$(NC)\n" "Fastlane production build failed"; \
						exit 1; \
					fi; \
				elif fastlane build_archive_production 2>/dev/null; then \
					printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS Archive and Production IPA created successfully"; \
				else \
					printf "$(RED)$(CROSS) %s$(NC)\n" "Fastlane production build failed"; \
					exit 1; \
				fi; \
				cd ..; \
				IPA_FILE=$$(find build/ios/ipa -name "*.ipa" | head -1); \
				if [ -n "$$IPA_FILE" ] && [ -f "$$IPA_FILE" ]; then \
					printf "$(GREEN)$(CHECK) %s$(NC)\n" "Production IPA exported successfully"; \
					cp "$$IPA_FILE" "$(OUTPUT_DIR)/$(IPA_PROD_NAME)"; \
					printf "$(GREEN)$(CHECK) %s$(NC)\n" "Production IPA copied to $(OUTPUT_DIR)/$(IPA_PROD_NAME)"; \
					printf "$(CYAN)$(GEAR) %s$(NC)\n" "Uploading to App Store..."; \
					cd ios; \
					if command -v bundle >/dev/null 2>&1 && [ -f "../Gemfile" ]; then \
						if bundle exec fastlane ios release 2>/dev/null; then \
							printf "$(GREEN)$(CHECK) %s$(NC)\n" "Successfully uploaded to App Store via bundle"; \
						elif fastlane ios release 2>/dev/null; then \
							printf "$(GREEN)$(CHECK) %s$(NC)\n" "Successfully uploaded to App Store"; \
						else \
							printf "$(YELLOW)$(WARNING) %s$(NC)\n" "App Store upload failed - check fastlane configuration"; \
							printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual upload: Use Xcode or: cd ios && bundle exec fastlane ios release"; \
						fi; \
					elif fastlane ios release 2>/dev/null; then \
						printf "$(GREEN)$(CHECK) %s$(NC)\n" "Successfully uploaded to App Store"; \
					else \
						printf "$(YELLOW)$(WARNING) %s$(NC)\n" "App Store upload failed - check fastlane configuration"; \
						printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual upload: Use Xcode or: cd ios && fastlane ios release"; \
					fi; \
					cd ..; \
				else \
					printf "$(RED)$(CROSS) %s$(NC)\n" "Production IPA export failed"; \
				fi; \
			else \
				printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Fastlane not available - falling back to xcodebuild"; \
				cd ios && xcodebuild -workspace Runner.xcworkspace -scheme Runner -configuration Release -destination "generic/platform=iOS" -archivePath ../build/ios/archive/Runner.xcarchive archive; \
				if [ $$? -eq 0 ] && [ -d "../build/ios/archive/Runner.xcarchive" ]; then \
					printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS Archive created successfully"; \
					cp -r "../build/ios/archive/Runner.xcarchive" "../$(OUTPUT_DIR)/$(ARCHIVE_PROD_NAME)"; \
					printf "$(GREEN)$(CHECK) %s$(NC)\n" "Archive copied to $(OUTPUT_DIR)/$(ARCHIVE_PROD_NAME)"; \
					printf "$(CYAN)$(GEAR) %s$(NC)\n" "Exporting Production IPA from Archive..."; \
					if [ -f "fastlane/ExportOptions.plist" ]; then \
						xcodebuild -exportArchive -archivePath ../build/ios/archive/Runner.xcarchive -exportPath ../build/ios/ipa -exportOptionsPlist fastlane/ExportOptions.plist; \
					else \
						TEMP_PLIST=$$(mktemp /tmp/ExportOptions.XXXXXX.plist); \
						printf '<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n<plist version="1.0">\n<dict>\n<key>method</key>\n<string>app-store</string>\n<key>uploadBitcode</key>\n<false/>\n<key>compileBitcode</key>\n<false/>\n<key>uploadSymbols</key>\n<true/>\n<key>signingStyle</key>\n<string>automatic</string>\n</dict>\n</plist>' > "$$TEMP_PLIST"; \
						xcodebuild -exportArchive -archivePath ../build/ios/archive/Runner.xcarchive -exportPath ../build/ios/ipa -exportOptionsPlist "$$TEMP_PLIST"; \
						rm -f "$$TEMP_PLIST"; \
					fi; \
					IPA_FILE=$$(find ../build/ios/ipa -name "*.ipa" 2>/dev/null | head -1); \
					if [ -z "$$IPA_FILE" ]; then \
						IPA_FILE=$$(find fastlane/builds -name "*.ipa" 2>/dev/null | head -1); \
					fi; \
					if [ -z "$$IPA_FILE" ]; then \
						IPA_FILE=$$(find .. -name "*.ipa" -path "*/build/*" -o -path "*/fastlane/*" 2>/dev/null | head -1); \
					fi; \
					if [ -n "$$IPA_FILE" ] && [ -f "$$IPA_FILE" ]; then \
					printf "$(GREEN)$(CHECK) %s$(NC)\n" "Production IPA exported successfully: $$IPA_FILE"; \
					cp "$$IPA_FILE" "../$(OUTPUT_DIR)/$(IPA_PROD_NAME)"; \
					printf "$(GREEN)$(CHECK) %s$(NC)\n" "Production IPA copied to $(OUTPUT_DIR)/$(IPA_PROD_NAME)"; \
					printf "$(CYAN)$(GEAR) %s$(NC)\n" "Uploading to App Store..."; \
					if command -v fastlane >/dev/null 2>&1 && [ -f "fastlane/Fastfile" ]; then \
						if command -v bundle >/dev/null 2>&1 && [ -f "../Gemfile" ]; then \
							if bundle exec fastlane ios release 2>/dev/null; then \
								printf "$(GREEN)$(CHECK) %s$(NC)\n" "Successfully uploaded to App Store via bundle"; \
							elif fastlane ios release 2>/dev/null; then \
								printf "$(GREEN)$(CHECK) %s$(NC)\n" "Successfully uploaded to App Store"; \
							else \
								printf "$(YELLOW)$(WARNING) %s$(NC)\n" "App Store upload failed - check fastlane configuration"; \
								printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual upload: Use Xcode or: cd ios && bundle exec fastlane ios release"; \
							fi; \
						elif fastlane ios release 2>/dev/null; then \
							printf "$(GREEN)$(CHECK) %s$(NC)\n" "Successfully uploaded to App Store"; \
						else \
							printf "$(YELLOW)$(WARNING) %s$(NC)\n" "App Store upload failed - check fastlane configuration"; \
							printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual upload: Use Xcode or: cd ios && fastlane ios release"; \
						fi; \
					else \
						printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Fastlane not available - manual App Store upload required"; \
						printf "$(CYAN)$(INFO) %s$(NC)\n" "Upload manually: Use Xcode Organizer or Transporter app"; \
						printf "$(CYAN)$(INFO) %s$(NC)\n" "IPA location: $(OUTPUT_DIR)/$(IPA_PROD_NAME)"; \
					fi; \
				else \
					printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Production IPA not found in expected locations - build may have succeeded but IPA location differs"; \
					printf "$(CYAN)$(INFO) %s$(NC)\n" "Check fastlane logs above for actual build status"; \
				fi; \
			fi; \
		fi; \
	else \
		printf "$(YELLOW)$(WARNING) %s$(NC)\n" "iOS build skipped (requires macOS)"; \
	fi
	
	@printf "$(GREEN)$(CHECK) %s$(NC)\n" "Production build completed"
	@printf "$(GREEN)üöÄ Live Production Pipeline (Local) Completed!$(NC)\n"
	@printf "$(WHITE)üìÅ Builder Directory:$(NC) $(OUTPUT_DIR)/\n"
	@printf "$(WHITE)üì¶ Android AAB:$(NC) $(OUTPUT_DIR)/$(AAB_NAME)\n"
	@printf "$(WHITE)üì¶ Android AAB (builder/):$(NC) builder/$(AAB_NAME)\n"
	@if [ "$$(uname)" = "Darwin" ] && [ -f "$(OUTPUT_DIR)/$(IPA_PROD_NAME)" ]; then \
		printf "$(WHITE)üçé iOS Production IPA:$(NC) $(OUTPUT_DIR)/$(IPA_PROD_NAME)\n"; \
		printf "$(WHITE)üçé iOS Production IPA (builder/):$(NC) builder/$(IPA_PROD_NAME)\n"; \
	fi
	
	@printf "\n"
	@printf "$(GREEN)$(CHECK) %s$(NC)\n" "Local production build and upload completed successfully!"
	@printf "$(CYAN)$(INFO) %s$(NC)\n" "Apps have been uploaded directly to stores via Fastlane"
	@printf "$(CYAN)$(INFO) %s$(NC)\n" "No GitHub Actions triggered - this was a local-only deployment"

live-github: ## ‚òÅÔ∏è Automated Live Production Pipeline (GitHub Actions Build & Upload)
	@printf "\n"
	@printf "$(CYAN)‚òÅÔ∏è Triggering GitHub Actions for Production Build & Upload$(NC)\n"
	@printf "$(CYAN)$(INFO) This will build and upload apps entirely on GitHub Actions$(NC)\n"
	@printf "\n"
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Validating GitHub secrets before deployment..."
	@if [ -f "scripts/github_secrets_validator.sh" ]; then \
		if bash scripts/github_secrets_validator.sh; then \
			printf "$(GREEN)$(CHECK) %s$(NC)\n" "GitHub secrets validation passed"; \
		else \
			printf "$(RED)$(CROSS) %s$(NC)\n" "GitHub secrets validation failed"; \
			printf "$(CYAN)$(INFO) %s$(NC)\n" "Please fix the secrets configuration before proceeding"; \
			exit 1; \
		fi; \
	else \
		printf "$(YELLOW)$(WARNING) %s$(NC)\n" "GitHub secrets validator not found - skipping validation"; \
	fi
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Interactive version selection..."
	@if command -v dart >/dev/null 2>&1; then \
		if dart scripts/dynamic_version_manager.dart interactive 2>/dev/null; then \
			printf "$(GREEN)$(CHECK) %s$(NC)\n" "Version applied successfully"; \
		else \
			printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Interactive version failed - using fallback"; \
			if dart scripts/dynamic_version_manager.dart set-strategy fallback_only && dart scripts/dynamic_version_manager.dart apply; then \
				printf "$(GREEN)$(CHECK) %s$(NC)\n" "Fallback version applied"; \
			else \
				printf "$(RED)$(CROSS) %s$(NC)\n" "Version management failed"; \
			fi; \
		fi; \
	else \
		printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Dart not found - skipping dynamic version management"; \
	fi
	
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Refreshing version information after interactive selection..."
	
	@# Read versions directly from files created by interactive mode
	@ANDROID_VERSION_NAME=$$(dart scripts/dynamic_version_manager.dart get-android-version-name 2>/dev/null || echo "1.0.0"); \
	ANDROID_VERSION_CODE=$$(dart scripts/dynamic_version_manager.dart get-android-version-code 2>/dev/null || echo "1"); \
	IOS_VERSION_NAME=$$(dart scripts/dynamic_version_manager.dart get-ios-version-name 2>/dev/null || echo "1.0.0"); \
	IOS_VERSION_CODE=$$(dart scripts/dynamic_version_manager.dart get-ios-version-code 2>/dev/null || echo "1"); \
	printf "$(GREEN)$(CHECK) %s$(NC)\n" "Version refreshed:"; \
	printf "$(CYAN)   üì± Android: $$ANDROID_VERSION_NAME+$$ANDROID_VERSION_CODE$(NC)\n"; \
	printf "$(CYAN)   üçé iOS: $$IOS_VERSION_NAME+$$IOS_VERSION_CODE$(NC)\n"; \
	ANDROID_VER="$$ANDROID_VERSION_NAME+$$ANDROID_VERSION_CODE"; \
	IOS_VER="$$IOS_VERSION_NAME+$$IOS_VERSION_CODE"; \
	if [ -z "$$ANDROID_VERSION_NAME" ] || [ -z "$$IOS_VERSION_NAME" ]; then \
		printf "$(RED)$(CROSS) %s$(NC)\n" "Could not extract Android/iOS versions from dynamic_version_manager"; \
		exit 1; \
	fi; \
	printf "$(CYAN)$(INFO) %s$(NC)\n" "Android version: $$ANDROID_VER"; \
	printf "$(CYAN)$(INFO) %s$(NC)\n" "iOS version: $$IOS_VER"; \
	TAG_NAME="android-$$ANDROID_VERSION_NAME-build-$$ANDROID_VERSION_CODE-ios-$$IOS_VERSION_NAME-build-$$IOS_VERSION_CODE"; \
	printf "$(CYAN)$(GEAR) %s$(NC)\n" "Creating git tag: $$TAG_NAME"; \
	if git tag -a "$$TAG_NAME" -m "üöÄ GitHub Actions Production Build & Upload - Android: $$ANDROID_VER, iOS: $$IOS_VER" 2>/dev/null; then \
		printf "$(GREEN)$(CHECK) %s$(NC)\n" "Git tag created: $$TAG_NAME"; \
	else \
		printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Git tag already exists or failed to create"; \
	fi; \
	printf "$(CYAN)$(GEAR) %s$(NC)\n" "Pushing git tag to trigger GitHub Actions..."; \
	if git push origin "$$TAG_NAME" 2>/dev/null; then \
		printf "$(GREEN)$(CHECK) %s$(NC)\n" "Git tag pushed successfully"; \
		printf "$(CYAN)$(GEAR) %s$(NC)\n" "GitHub Actions triggered by tag push"; \
		printf "$(GREEN)$(ROCKET) %s$(NC)\n" "Monitor deployment: https://github.com/$$(git remote get-url origin | sed 's/.*github.com[:/]\([^.]*\).*/\1/')/actions"; \
		printf "$(CYAN)$(INFO) %s$(NC)\n" "GitHub Actions will build and upload apps to production stores"; \
	else \
		printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Git push failed - trying GitHub API trigger..."; \
		if command -v gh >/dev/null 2>&1; then \
			printf "$(CYAN)$(GEAR) %s$(NC)\n" "Using GitHub CLI to trigger workflow..."; \
			if gh workflow run deploy.yml --field environment=production --field platforms=all 2>/dev/null; then \
				printf "$(GREEN)$(CHECK) %s$(NC)\n" "GitHub Actions triggered via API"; \
				printf "$(GREEN)$(ROCKET) %s$(NC)\n" "Monitor deployment: gh run list --workflow=deploy.yml"; \
			else \
				printf "$(YELLOW)$(WARNING) %s$(NC)\n" "GitHub CLI trigger failed"; \
				printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual trigger: Go to GitHub ‚Üí Actions ‚Üí Run workflow"; \
			fi; \
		else \
			printf "$(YELLOW)$(WARNING) %s$(NC)\n" "GitHub CLI not found"; \
			printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual trigger: Go to GitHub ‚Üí Actions ‚Üí Run workflow"; \
		fi; \
	fi
	
	@printf "\n"
	@printf "$(GREEN)$(ROCKET) %s$(NC)\n" "GitHub Actions deployment initiated!"
	@printf "$(CYAN)$(INFO) %s$(NC)\n" "No local build performed - everything happens on GitHub Actions"
	@printf "$(CYAN)$(INFO) %s$(NC)\n" "Apps will be built and uploaded to stores automatically"

trigger-github-actions: ## üöÄ Trigger GitHub Actions CI/CD (Tag Push + API)
	@printf "\n"
	@printf "$(CYAN)üöÄ Triggering GitHub Actions CI/CD$(NC)\n"
	@printf "\n"
	$(eval ANDROID_VERSION_NAME := $(call get_android_version_name))
	$(eval ANDROID_VERSION_CODE := $(call get_android_version_code))
	$(eval IOS_VERSION_NAME := $(call get_ios_version_name))
	$(eval IOS_VERSION_CODE := $(call get_ios_version_code))
	@ANDROID_VER="$(ANDROID_VERSION_NAME)+$(ANDROID_VERSION_CODE)"; \
	IOS_VER="$(IOS_VERSION_NAME)+$(IOS_VERSION_CODE)"; \
	if [ -z "$(ANDROID_VERSION_NAME)" ] || [ -z "$(IOS_VERSION_NAME)" ]; then \
		printf "$(RED)$(CROSS) %s$(NC)\n" "Could not extract Android/iOS versions from dynamic_version_manager"; \
		exit 1; \
	fi; \
	printf "$(CYAN)$(INFO) %s$(NC)\n" "Android version: $$ANDROID_VER"; \
	printf "$(CYAN)$(INFO) %s$(NC)\n" "iOS version: $$IOS_VER"; \
	TAG_NAME="android-$(ANDROID_VERSION_NAME)-build-$(ANDROID_VERSION_CODE)_ios-$(IOS_VERSION_NAME)-build-$(IOS_VERSION_CODE)"; \
	printf "$(CYAN)$(GEAR) %s$(NC)\n" "Creating git tag: $$TAG_NAME"; \
	if git tag -a "$$TAG_NAME" -m "üöÄ Production release - Android: $$ANDROID_VER, iOS: $$IOS_VER" 2>/dev/null; then \
		printf "$(GREEN)$(CHECK) %s$(NC)\n" "Git tag created: $$TAG_NAME"; \
	else \
		printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Git tag already exists or failed to create"; \
	fi; \
	printf "$(CYAN)$(GEAR) %s$(NC)\n" "Pushing git tag to remote..."; \
	if git push origin "$$TAG_NAME" 2>/dev/null; then \
		printf "$(GREEN)$(CHECK) %s$(NC)\n" "Git tag pushed successfully"; \
		printf "$(CYAN)$(GEAR) %s$(NC)\n" "GitHub Actions triggered by tag push"; \
		printf "$(GREEN)$(ROCKET) %s$(NC)\n" "Monitor deployment: https://github.com/$$(git remote get-url origin | sed 's/.*github.com[:/]\([^.]*\).*/\1/')/actions"; \
	else \
		printf "$(YELLOW)$(WARNING) %s$(NC)\n" "Git push failed - trying GitHub API trigger..."; \
		if command -v gh >/dev/null 2>&1; then \
			printf "$(CYAN)$(GEAR) %s$(NC)\n" "Using GitHub CLI to trigger workflow..."; \
			if gh workflow run deploy.yml --field environment=production --field platforms=all 2>/dev/null; then \
				printf "$(GREEN)$(CHECK) %s$(NC)\n" "GitHub Actions triggered via API"; \
				printf "$(GREEN)$(ROCKET) %s$(NC)\n" "Monitor deployment: gh run list --workflow=deploy.yml"; \
			else \
				printf "$(YELLOW)$(WARNING) %s$(NC)\n" "GitHub CLI trigger failed"; \
				printf "$(CYAN)$(INFO) %s$(NC)\n" "Manual trigger: Go to GitHub ‚Üí Actions ‚Üí Run workflow"; \
			fi; \
		else \
			printf "$(YELLOW)$(WARNING) %s$(NC)\n" "GitHub CLI not found"; \
			printf "$(CYAN)$(INFO) %s$(NC)\n" "Install: brew install gh"; \
			printf "$(CYAN)$(INFO) %s$(NC)\n" "Or trigger manually on GitHub"; \
		fi; \
	fi
	@printf "\n"
	@printf "$(GREEN)üöÄ GitHub Actions Pipeline Triggered!$(NC)\n"
	@printf "$(CYAN)$(INFO) %s$(NC)\n" "Check GitHub Actions for automated deployment status"

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üîç SYSTEM & DIAGNOSTICS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

system-check: ## üîç Comprehensive System Configuration Check
	@printf "$(CYAN)üîç System Configuration Check$(NC)\n"
	@printf "\n"
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Checking Flutter installation..."
	@if command -v flutter >/dev/null 2>&1; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "Flutter installed"; else printf "$(RED)$(CROSS) %s$(NC)\n" "Flutter not installed"; fi
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Checking project structure..."
	@if [ -f "pubspec.yaml" ]; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "pubspec.yaml found"; else printf "$(RED)$(CROSS) %s$(NC)\n" "pubspec.yaml missing"; fi
	@if [ -d "android" ]; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "Android directory found"; else printf "$(RED)$(CROSS) %s$(NC)\n" "Android directory missing"; fi
	@if [ -d "ios" ]; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS directory found"; else printf "$(RED)$(CROSS) %s$(NC)\n" "iOS directory missing"; fi
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Checking CI/CD configuration..."
	@if [ -f "android/fastlane/Fastfile" ]; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "Android Fastlane configured"; else printf "$(RED)$(CROSS) %s$(NC)\n" "Android needs setup - See docs/ANDROID_SETUP_GUIDE.md"; fi
	@if [ -f "ios/fastlane/Fastfile" ]; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "iOS Fastlane configured"; else printf "$(RED)$(CROSS) %s$(NC)\n" "iOS needs setup - See docs/IOS_SETUP_GUIDE.md"; fi
	@if [ -f ".github/workflows/deploy.yml" ]; then printf "$(GREEN)$(CHECK) %s$(NC)\n" "GitHub Actions configured"; else printf "$(RED)$(CROSS) %s$(NC)\n" "GitHub Actions needs setup"; fi

system-tester: system-check ## üß™ Alias for system-check (checks system for tester deployment)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üì¶ DEPENDENCIES & SETUP
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

deps: ## üì¶ Installing dependencies
	@echo "üì¶ Installing dependencies..."
	flutter pub get
	cd android && bundle install
	cd ios && bundle install && pod install

setup: ## Setup and configure development environment
	@printf "\n"
	@printf "$(BLUE)‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó$(NC)\n"
	@printf "$(BLUE)‚ïë$(NC) $(GEAR) $(WHITE)Development Environment Setup$(NC) $(BLUE)‚ïë$(NC)\n"
	@printf "$(BLUE)‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù$(NC)\n"
	@printf "\n"
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Installing Dependencies"
	@flutter pub get > /dev/null && printf "$(GREEN)$(CHECK) %s$(NC)\n" "Flutter packages updated"
	@printf "$(GREEN)$(CHECK) %s$(NC)\n" "Development environment setup completed successfully!"
	@printf "\n"

doctor: ## Run comprehensive health checks and diagnostics
	@printf "\n"
	@printf "$(BLUE)‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó$(NC)\n"
	@printf "$(BLUE)‚ïë$(NC) $(MAGNIFY) $(WHITE)System Health Check & Diagnostics$(NC) $(BLUE)‚ïë$(NC)\n"
	@printf "$(BLUE)‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù$(NC)\n"
	@printf "\n"
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Flutter Doctor Diagnosis"
	@printf "$(GRAY)Running Flutter doctor...$(NC)\n"
	@flutter doctor -v
	@printf "$(GRAY)‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ$(NC)\n"
	@printf "$(CYAN)$(GEAR) %s$(NC)\n" "Project Configuration"
	@printf "$(PURPLE)$(BOLD)Project Details:$(NC)\n"
	@printf "$(WHITE)  $(PHONE) Name:$(NC)          $(CYAN)$(PROJECT_NAME)$(NC)\n"
	@printf "$(WHITE)  $(PACKAGE) Package:$(NC)       $(CYAN)$(PACKAGE_NAME)$(NC)\n"
	@printf "$(WHITE)  $(SPARKLES) Version:$(NC)       $(CYAN)$(VERSION_FULL)$(NC)\n"
	@printf "$(WHITE)  $(COMPUTER) Flutter:$(NC)       $(CYAN)%s$(NC)\n" "$$(flutter --version | head -1 | cut -d' ' -f2)"
	@printf "\n"

clean: ## üßπ Cleaning
	@echo "üßπ Cleaning..."
	flutter clean
	rm -rf $(OUTPUT_DIR)

build: ## üî® Building
	@echo "üî® Building..."
	mkdir -p $(OUTPUT_DIR)
	flutter build apk --release
	flutter build appbundle --release

test: ## üß™ Running tests
	@echo "üß™ Running tests..."
	flutter test